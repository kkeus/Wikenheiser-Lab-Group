classdef Utility < arduinoio.internal.accessor
    %

    %   Copyright 2017-2024 The MathWorks, Inc.

    properties(Access = protected)
        BoardInfo
    end

    properties(Access = private)
        CurrentSystemPath
        CurrentCPath
        CurrentDYLDLibPath
        DeleteTempDir
        AutoGeneratedWrapperFilesRequired
    end


    methods (Abstract)
        buildInfo = setProgrammer(obj, buildInfo);
    end

    %% Constructor
    methods
        function obj = Utility
            obj.BoardInfo = arduinoio.internal.BoardInfo.getInstance();
        end
    end

    %% Public methods
    methods(Static)
        function pressBootButtonDialog
            % Get Test Preference and launch the dlg based on the status
            prefStatus = arduinoio.internal.Utility.getBootButtonTestPreference;
            if ~prefStatus
                uiwait(msgbox(message('MATLAB:arduinoio:general:pressBootButton').getString,'modal'));
            end
        end

        function releaseBootButtonDialog
            % Get Test Preference and launch the dlg based on the status
            prefStatus = arduinoio.internal.Utility.getBootButtonTestPreference;
            if ~prefStatus
                uiwait(msgbox(message('MATLAB:arduinoio:general:releaseBootButton').getString,'modal'));
            end
        end

        function prefStatus = getBootButtonTestPreference
            % Getting the test preference status to enable automated tests
            % to be unblocked by the Boot Button Press dlg
            prefStatus = false;
            if ispref('MATLAB_HARDWARE','Test_NoBootButtonPressESP32')
                prefStatus = getpref('MATLAB_HARDWARE','Test_NoBootButtonPressESP32');
            end
        end
    end

    methods (Access = private)
        function [status, result] = buildServer(~,buildInfo)
            if exist(fullfile(buildInfo.TempDirPath, 'MW'), 'dir')
                % Check if user can delete the folder successfully.
                try
                    rmdir(fullfile(buildInfo.TempDirPath, 'MW'), 's');
                catch
                    matlabshared.hwsdk.internal.localizedError('MATLAB:hwsdk:general:unableToDeleteFolder',fullfile(buildInfo.TempDirPath, 'MW'));
                end
            end
            buildCmd = [buildInfo.Programmer, ' -v --fqbn ', buildInfo.Package, ':', buildInfo.Arch, ':', buildInfo.BoardName];
            if ~isempty(buildInfo.CPU)
                buildCmd = [buildCmd, ':cpu=', buildInfo.CPU];
            end
            buildCmd = [buildCmd, ' compile ','"', buildInfo.TempDirPath,'"'];%Added quotes around sketchfile path to overcome error caused by tempdir not resolving space in filepath
            buildCmd = [buildCmd, ' --build-path ', '"',fullfile(buildInfo.TempDirPath, 'MW'),'"'];%Added quotes around sketchfile path to overcome error caused by tempdir not resolving space in filepath
            buildCmd = [buildCmd, ' --config-file ', '"', buildInfo.ConfigurationFile, '"'];

            if strcmpi(buildInfo.Arch,'renesas_uno')
                % Manually specify the output directory for the binaries
                buildCmd = [buildCmd, ' --output-dir "' buildInfo.TempDirPath '"'];

                % Most of the 3p libraries make use of NOT_AN_INTERRUPT
                % defines and this definition is not available for
                % Renesas Uno core. Adding this definition manually
                buildCmd = [buildCmd, ' --build-property build.extra_flags=-DNOT_AN_INTERRUPT=-1 '];
            end
            [status, result] = system(buildCmd);
        end
    end

    %% Public methods
    methods (Access = public)

        function validateCLIPath(obj, CLIPath)
            % Check if the given CLIPath points to the supported version of
            % AVR core and contains all the required files for this core.
            avrCoreVersion = char(arduinoio.internal.ArduinoConstants.CoreVersions("avr"));
            files = {fullfile('data','packages', 'arduino', 'hardware', 'avr', avrCoreVersion, 'cores', 'arduino', 'hooks.c')};
            for i = 1:length(files)
                if ~exist(fullfile(CLIPath, files{i}), 'file')
                    matlabshared.hwsdk.internal.localizedError('MATLAB:arduinoio:general:invalidCLIPath', CLIPath)
                end
            end
        end


        function [status,result] = complete3pInstall(obj,buildInfo)
            % Get programmer info
            buildInfo = getProgrammer(obj, buildInfo);

            % Set the downloads to aCLI directory on linux alone.
            if strcmpi(computer('arch'),'glnxa64') && ~(matlabshared.remoteconnectivity.internal.RemoteUtilities.isUsingRemoteHW)
                % Set the download folder
                configCmd = [buildInfo.Programmer,' config set directories.downloads ', ' "',fullfile(arduinoio.CLIRoot,'downloads'), '" ', ' --config-file ', buildInfo.ConfigurationFile];
                [status, result] = system(configCmd); %#ok<ASGLU>
            end

            % set of commands to install ESP32 core
            configCmd = strcat(buildInfo.Programmer," config set board_manager.additional_urls " , char(arduinoio.internal.ArduinoConstants.ThirdPartyURLs('ESP32')), " --config-file ", buildInfo.ConfigurationFile);
            [status, result] = system(configCmd); %#ok<ASGLU>
            % Adding additional URL flag in the following command is required because when launching MATLAB without non-admin privileges,
            % the acli command fails to set the additional URL flag in the yaml file.
            searchCmd = [buildInfo.Programmer, ' core search esp32 --config-file ', buildInfo.ConfigurationFile ' --additional-urls ' char(arduinoio.internal.ArduinoConstants.ThirdPartyURLs('ESP32'))];
            [status, result] = system(searchCmd); %#ok<ASGLU>
            espCoreVersion = char(arduinoio.internal.ArduinoConstants.CoreVersions("esp"));
            installCmd = [buildInfo.Programmer, ' core install esp32:esp32@' espCoreVersion '  --config-file ', buildInfo.ConfigurationFile ' --additional-urls ' char(arduinoio.internal.ArduinoConstants.ThirdPartyURLs('ESP32'))];
            [status, result] = system(installCmd);
        end

        function [status] = completeServoESP323pInstall(obj,buildInfo)
            % Get programmer info
            buildInfo = getProgrammer(obj, buildInfo);

            % Set the downloads to aCLI directory on linux alone.
            if strcmpi(computer('arch'),'glnxa64') && ~(matlabshared.remoteconnectivity.internal.RemoteUtilities.isUsingRemoteHW)
                % Set the download folder
                configCmd = [buildInfo.Programmer,' config set directories.downloads ', ' "',fullfile(arduinoio.CLIRoot,'downloads'), '" ', ' --config-file ', buildInfo.ConfigurationFile];
                [status, result] = system(configCmd); %#ok<ASGLU>
            end

            servoEsp32LibVersion = char(arduinoio.internal.ArduinoConstants.LibVersions("ServoESP32"));
            % Adding additional URL flag in the following command is required because when launching MATLAB without non-admin privileges,
            % the acli command fails to set the additional URL flag in the yaml file.
            installCmd = [buildInfo.Programmer, ' lib install ServoESP32@' servoEsp32LibVersion ' --config-file ', buildInfo.ConfigurationFile ' --additional-urls ' char(arduinoio.internal.ArduinoConstants.ThirdPartyURLs('ESP32'))];    % directly install library using 'arduino-cli lib install ServoESP32'
            [status,~] = system(installCmd);
        end

        function varargout = updateServer(obj, buildInfo)
            % This function compiles all necessary source files and downloads
            % the executable to the hardware

            % Error out if it tries to build for unsupported boards in
            % MATLAB Online. Originally we only check this in uploadServer.
            % But there are some leak in preBuildProcess, which checks
            % existence of ESP32 tools, which does not exist in MATLAB
            % Online.
            % TODO The RemoteUtilities does not support MATLAB
            % compiler deployment yet, need to remove the %#exclude
            % and isdeployed condition below once g3238819 is resolved
            %#exclude matlabshared.remoteconnectivity.internal.RemoteUtilities.isUsingRemoteHW
            if ~isdeployed && matlabshared.remoteconnectivity.internal.RemoteUtilities.isUsingRemoteHW
                if ismember(buildInfo.Board, arduinoio.internal.ArduinoConstants.BoardsNotSupportedInOnline)
                    % ESP32 and Uno R4 support is pending the TODO items below
                    % Error out for now
                    matlabshared.hwsdk.internal.localizedError('MATLAB:arduinoio:general:BoardsNotSupportedMATLABOnline',char(buildInfo.Board));
                end
            end

            % global flag for device plugin detection
            global ArduinoDevicePluginDetectionClient;
            clrGlobal = onCleanup(@()evalc('clearvars -global ArduinoDevicePluginDetectionClient'));
            origPort = buildInfo.Port;

            % This is required to run non hw tests
            if ~ispref('MATLAB_HARDWARE','Test_BuildOnly')
                % Check if serialport is free before updating the server.
                % Get the available serial port
                if isdeployed || ~matlabshared.remoteconnectivity.internal.RemoteUtilities.isUsingRemoteHW()
                    portList = serialportlist('available');
                else
                    remoteUtilsObj = matlabshared.remoteconnectivity.internal.RemoteUtilities;
                    portList = remoteUtilsObj.serialportlist('available');
                end

                % Error if the port is not available/free
                if ~ismember(origPort,portList)
                    matlabshared.hwsdk.internal.localizedError('MATLAB:hwsdk:general:invalidPort', 'Arduino', origPort);
                end
            end

            buildInfo = preBuildProcess(obj, buildInfo); % populate the complete set of fields in buildInfo structure
            if exist(buildInfo.TempDirPath, 'dir')
                % Check if user can delete the folder successfully.
                try
                    rmdir(buildInfo.TempDirPath, 's');
                catch
                    matlabshared.hwsdk.internal.localizedError('MATLAB:hwsdk:general:unableToDeleteFolder',buildInfo.TempDirPath);
                end
            end
            obj.DeleteTempDir = (buildInfo.ConnectionType==matlabshared.hwsdk.internal.ConnectionTypeEnum.WiFi);
            generatePeripheralIncludeHeader(obj,buildInfo);
            generateAddonLibrariesHeader(obj, buildInfo);
            generateMacrosIncludeHeader(obj, buildInfo);
            generateMainSketch(obj, buildInfo);

            % Add tempdir to compiler's header file search dir
            obj.CurrentCPath = getenv('CPATH');
            setenv('CPATH', buildInfo.TempDirPath);
            if ispc
                obj.CurrentSystemPath = getenv('PATH');
                % Add 3P path ahead to avoid interference with other drivers like WinAVR
                setenv('PATH', [buildInfo.CLIPath, ';', obj.CurrentSystemPath]);
            elseif ismac
                % Reset environment variable to avoid Java interference
                % with Arduino IDE(default JAVA 8 runtime)
                obj.CurrentDYLDLibPath = getenv('DYLD_LIBRARY_PATH');
                setenv('DYLD_LIBRARY_PATH','');
            end
            c = onCleanup(@() cleanup(obj));

            errorMsg = '';

            if ispref('MATLAB_HARDWARE','Test_BuildOnly')
                % Build server for build only test
                [status, result] = buildServer(obj,buildInfo);
                if status
                    disp(result);
                end
            else
                [status, result] = uploadServer(obj, buildInfo);
            end

            if status
                errorMsg = result;
            else
                % Wrong boards specified or board(Due and MKR1000) not programmable
                if contains(result, 'attempt 10 of 10: not in sync:')||...
                        contains(result, 'Unsupported processor')||...
                        contains(result, 'stk500v2_getsync(): timeout communicating with programmer')||...
                        contains(result, ['No device found on ', buildInfo.Port])
                    status = 1;
                    errorMsg = result;
                end
            end
            varargout{1} = errorMsg;

            if status
                if isdeployed()
                    matlabshared.hwsdk.internal.localizedError('MATLAB:hwsdk:general:failedUpload', buildInfo.Board, origPort);
                else
                    if ~buildInfo.ShowUploadResult
                        matlabshared.hwsdk.internal.localizedError('MATLAB:arduinoio:general:failedUpload', buildInfo.Board, origPort);
                    else
                        % Display the error logs from the CLI when trace on is set to true
                        matlabshared.hwsdk.internal.localizedError('MATLAB:arduinoio:general:failedUploadVerbose', errorMsg);
                    end
                end
            else
                % Check compiled hex size fits in the flash memory
                validateServerSize(obj, buildInfo);

                if ismember(buildInfo.Board, arduinoio.internal.ArduinoConstants.BoardsRequireShortPause)
                    % Add a pause to make sure serial port is ready for connection post IO server deployment
                    pause(5);
                elseif buildInfo.ConnectionType==matlabshared.hwsdk.internal.ConnectionTypeEnum.WiFi && ismember(buildInfo.Board,arduinoio.internal.ArduinoConstants.BoardsRequireLongPause)
                    pause(15);
                end
            end


            function cleanup(obj)
                if ~isdeployed()
                    % Turn-on Arduino plugin detection
                    internal.deviceplugindetection.EnableArduinoHotPlug.getInstance.setEnableArduinoDPDM(true);
                end
                try
                    if obj.DeleteTempDir && exist(buildInfo.TempDirPath, 'dir')
                        % Check if user can delete the folder successfully.
                        try
                            rmdir(buildInfo.TempDirPath, 's');
                        catch
                            matlabshared.hwsdk.internal.localizedError('MATLAB:hwsdk:general:unableToDeleteFolder',buildInfo.TempDirPath);
                        end
                    end
                catch % only attempt to delete the temp folder and not throw any error
                end
                setenv('CPATH', obj.CurrentCPath);
                if ispc
                    setenv('PATH', obj.CurrentSystemPath);
                elseif ismac
                    setenv('DYLD_LIBRARY_PATH', obj.CurrentDYLDLibPath);
                end
            end

        end

        function alternateHeaderSearch = areAlternateLibraryHeadersAvailableImpl(~, buildInfo)
            % Generates a logical array called alternateHeaderSearch
            % A true entry means the corresponding library in the
            % includedLibs has an alternate header associated with it
            % Checks if any alternate 3P header file is associated with the
            % specified library list and boards
            includedLibs = buildInfo.Libraries;
            includedLibs(ismember(includedLibs,{'I2C','SPI'})) = [];
            alternateHeaderSearch =  false(length(includedLibs),1);
            alternateLibHeaderSupportList = arduinoio.internal.ArduinoConstants.AlternateLibraryHeaderSupport;
            % check if specified library has an alternate library header
            for libCount = 1:length(includedLibs)
                %alternateHeaderSearch{libCount} = false;
                alternateLibHeaderAvailable = cellfun(@(x)ismember(x{1}, includedLibs(libCount)), alternateLibHeaderSupportList, 'UniformOutput', true);
                if any(alternateLibHeaderAvailable)
                    alternateLibHeaderAvailable = double(find(alternateLibHeaderAvailable > 0));
                    % check if the specified board is associated with the specified library
                    if ismember(buildInfo.Board, alternateLibHeaderSupportList{alternateLibHeaderAvailable(1)}{2})
                        alternateHeaderSearch(libCount) = true;
                    end
                end
            end

        end

    end


    %% Private methods
    methods(Access=private)
        function [missingHeaders, libs] = areLibrariesAvailable(~, buildInfo)
            % Check if a library folder has been installed in the
            % CLI libraries folder.
            searchDirectories = fullfile(buildInfo.CLIPath, 'user', 'libraries');

            allInstalledLibraries = '';
            result = dir(searchDirectories);
            isSubDir = [result(:).isdir];
            libDirs = {result(isSubDir).name}';
            libDirs(ismember(libDirs,{'.','..'})) = [];
            if ~isempty(libDirs)
                if isempty(allInstalledLibraries)
                    allInstalledLibraries = strcat(allInstalledLibraries, strjoin(libDirs, ', '));
                else
                    allInstalledLibraries = [allInstalledLibraries, ', ', strjoin(libDirs, ', ')];  %#ok<AGROW>
                end
            end

            libs = {};
            mheaders = {};
            includedLibs = buildInfo.Libraries;
            includedLibs(ismember(includedLibs,{'I2C','SPI'})) = [];

            % Check if an alternate library is available for user
            % specified libraries. See arduinoio.internal.ArduinoConstants.AlternateLibrariesSupport
            % for list of such libraries and boards associated with them.
            % E.g. MotorCarrier library specified on MKR boards (listed in AlternateLibrariesSupport) must select
            % the 3P header file i.e MMKRMotorCarrier.h, associated with the alternate library (MKRMotorCarrier) instead of
            % ArduinoMotorCarrier.h listed under the MotorCarrier class
            if isfield(buildInfo, 'AlternateLibraryHeadersAvailable')
                alternateHeaderStatus = buildInfo.AlternateLibraryHeadersAvailable;
            else
                alternateHeaderStatus = false(length(includedLibs),1);
            end

            for libCount = 1:length(includedLibs)
                % Check if an alternate library header file is available for the
                % specified library. Get the headerFile associated with the specified library in other case.
                headerFile = arduinoio.internal.getDefaultLibraryPropertyValue(includedLibs{libCount}, 'LibraryHeaderFiles', alternateHeaderStatus(libCount));
                if ~isempty(headerFile)
                    if ischar(headerFile)
                        headerFile = {headerFile};
                    end
                    % Split the headerFile(s) name w.r.t the '/' file
                    % separator
                    headerFileSplit = cellfun(@(x)strsplit(x, '/'), headerFile, 'UniformOutput',false);
                    % Retain the folder name of the arduino source file
                    theLib = cellfun(@(x) x(1), headerFileSplit, 'UniformOutput',false);
                    % Check if the arduino source files exists for the
                    % specified library
                    mheadersCheck = cellfun(@(x) ~contains(allInstalledLibraries, x), theLib);
                    if any(mheadersCheck)
                        libs = [libs, includedLibs{libCount}]; %#ok<AGROW>
                        % Find the index of the missing header file
                        mheaderIndex = find(double(mheadersCheck) == 1);
                        % Append the mising header file to the mheaders
                        % cell array
                        mheaders = [mheaders, headerFile{mheaderIndex}]; %#ok<AGROW>
                    end
                end
            end

            if isempty(libs)
                missingHeaders = '';
            else
                missingHeaders =  matlabshared.hwsdk.internal.renderCellArrayOfCharVectorsToCharVector(mheaders, ', ');
            end
        end

        function buildInfo = getProgrammer(obj, buildInfo)
            if ~isdeployed()
                buildInfo.CLIPath = arduinoio.CLIRoot;
                validateCLIPath(obj, buildInfo.CLIPath);
            end
            buildInfo = setProgrammer(obj, buildInfo);
        end


        function generateMacrosIncludeHeader(obj, buildInfo)
            % Generate Dynamic.h file to be compiled with other source code to
            % register the libraries
            filename = fullfile(buildInfo.TempDirPath, 'MacroIncludeIO.h');
            h = fopen(filename, 'w');
            c = onCleanup(@() fclose(h));

            contents = [];
            contents = ['#ifndef Macro_Include_h\n',...
                '#define Macro_Include_h\n'];

            if ismember(buildInfo.ConnectionType, [matlabshared.hwsdk.internal.ConnectionTypeEnum.Serial, matlabshared.hwsdk.internal.ConnectionTypeEnum.Bluetooth])
                contents = [contents, '\n#define CUSTOM_SERIAL_COMPORTBAUD ', buildInfo.BaudRate, '\n',...
                    '#define CUSTOM_EXPECTED_FIRSTBYTE_SERIAL ', '0xAA', '\n'];
                % For Arduino Leonardo and Micro boards with BT the
                % Serial1 is available on Board to connect BT module and
                % Serial 0 is a CDC COM Port
                %logic was ported from the cpp file to make it scalable for both connected IO and MATLAB IO workflows
                if (buildInfo.ConnectionType == matlabshared.hwsdk.internal.ConnectionTypeEnum.Bluetooth) && ismember(buildInfo.Board,{'Leonardo','Micro'})
                    contents = [contents, '#define serialPort Serial1\n'];
                else
                    if isfield(buildInfo,'SerialPort') && (~isequal(buildInfo.SerialPort,'0'))% Simulink Connected IO
                        contents = [contents,'#define serialPort Serial',buildInfo.SerialPort,'\n'];%#ok<AGROW>
                    else % common for MATLAB/Simulink Workflow
                        contents = [contents,'#define serialPort Serial\n'];
                    end
                end
            elseif (buildInfo.ConnectionType == matlabshared.hwsdk.internal.ConnectionTypeEnum.WiFi)% 'wifi'
                contents = [contents, '\n#define _RTT_BAUDRATE_SERIAL0_ 9600\n'];
                switch buildInfo.Encryption
                    case matlabshared.hwsdk.internal.WiFiEncryptionTypeEnum.None
                        contents = [contents, '\n#define _RTT_WIFI_NONE 1\n'];
                    case matlabshared.hwsdk.internal.WiFiEncryptionTypeEnum.WPA
                        contents = [contents, '\n#define _RTT_WIFI_WPA 1\n'];
                    case matlabshared.hwsdk.internal.WiFiEncryptionTypeEnum.WEP
                        contents = [contents, '\n#define _RTT_WIFI_WEP 1\n'];
                end
                contents = [contents, '\n#define MW_PORT '    , num2str(buildInfo.TCPIPPort), '\n'];
                switch buildInfo.Encryption
                    case matlabshared.hwsdk.internal.WiFiEncryptionTypeEnum.None
                        contents = [contents, '\n#define _RTT_WIFI_SSID '    , buildInfo.SSID, '\n'];
                    case matlabshared.hwsdk.internal.WiFiEncryptionTypeEnum.WPA
                        contents = [contents, '\n#define _RTT_WIFI_SSID '    , buildInfo.SSID, '\n'];
                        contents = [contents, '\n#define _RTT_WIFI_WPA_PASSWORD ', buildInfo.Password, '\n'];
                    case matlabshared.hwsdk.internal.WiFiEncryptionTypeEnum.WEP
                        contents = [contents, '\n#define _RTT_WIFI_SSID ', buildInfo.SSID, '\n'];
                        contents = [contents, '\n#define _RTT_WIFI_KEY ', buildInfo.Key, '\n'];
                        contents = [contents, '\n#define _RTT_WIFI_KEY_INDEX ', buildInfo.KeyIndex, '\n'];
                end
                if ~isempty(buildInfo.StaticIP)
                    contents = [contents, '\n#define _RTT_DISABLE_Wifi_DHCP_ 1\n'];
                    output = strsplit(buildInfo.StaticIP, '.');
                    for index = 1:4
                        contents = [contents, '\n#define _RTT_WIFI_Local_IP', num2str(index), ' ', output{index}, '\n']; %#ok<AGROW>
                    end
                else
                    contents = [contents, '\n#define _RTT_DISABLE_Wifi_DHCP_ 0\n'];
                end
            elseif (buildInfo.ConnectionType == matlabshared.hwsdk.internal.ConnectionTypeEnum.BLE)
                libs = char(strjoin(buildInfo.Libraries,','));
                contents = [contents, '\n#define BLEADVERTISINGNAME "',buildInfo.DeviceName, '"\n'];
                contents = [contents, '\n#define SERVICEUUID "',arduinoio.internal.ArduinoConstants.ServiceUUID,'"\n'];
                contents = [contents, '\n#define WRITECHARACTERISTICUUID "',arduinoio.internal.ArduinoConstants.WriteCharacteristicUUID,'"\n'];
                contents = [contents, '\n#define READCHARACTERISTICUUID "',arduinoio.internal.ArduinoConstants.ReadCharacteristicUUID,'"\n'];
                contents = [contents, '\n#define LIBNAMES ',' ','"',libs,'"','\n'];
                % Define macro for ESP BLE. This macro will help in differentiating between ESP32 BLE APIs used in the server code.
                if strcmpi(buildInfo.Arch,'esp32')
                    contents = [contents, '\n#define ESP_BLE 1\n'];
                end
            end
            contents = [contents,'#endif'];
            try
                fwrite(h, sprintf(contents));
            catch
                f2 = strrep(filename, '\', '\\');
                matlabshared.hwsdk.internal.localizedError('MATLAB:hwshared:general:noWritePermission');
            end
        end

        function generateMainSketch(obj, buildInfo)
            % Copy ArduinoServer.ino to tempdir
            [h, ~] = fopen(buildInfo.SketchTemplate);
            if h < 0
                matlabshared.hwsdk.internal.localizedError('MATLAB:hwshared:general:missingFile', buildInfo.SketchTemplate, 'ML_ARDUINO');
            else
                contents = transpose(fread(h, '*char'));
            end
            fclose(h);

            h = fopen(buildInfo.SketchFile, 'w');
            try
                fwrite(h, sprintf(contents));
            catch
                f2 = strrep(filename, '\', '\\');
                matlabshared.hwsdk.internal.localizedError('MATLAB:hwshared:general:noWritePermission');
            end
            fclose(h);
            % function to copy IoServer files from source
            arduinoio.internal.CopyServerToTemp(buildInfo.ConnectionType,buildInfo.TempDirPath);
            % function to copy autogenerated peripheral wrapper files and drivers from source
            if obj.AutoGeneratedWrapperFilesRequired==1
                arduinoio.internal.CopyAutoGeneratedPeripheralWrappersToTemp(buildInfo.TempDirPath,buildInfo.Arch,buildInfo.Libraries,buildInfo.Package);
            end
        end

        function output = getAllLibraryBuildInfo(~, libs, propName)
            % Return combined values for given property name of all given
            % libraries for the given architecture
            output = cell(1, numel(libs));
            for libCount = 1:length(libs)
                theLib = libs{libCount};
                value = obj.getDefaultLibraryPropertyValue(theLib, propName);
                output{libCount} = value;
            end
            output = unique(output);
        end

        function [status, result] = uploadServer(obj, buildInfo)
            if exist(fullfile(buildInfo.TempDirPath, 'MW'), 'dir')
                try
                    rmdir(fullfile(buildInfo.TempDirPath, 'MW'), 's');
                catch
                    matlabshared.hwsdk.internal.localizedError('MATLAB:hwsdk:general:unableToDeleteFolder', fullfile(buildInfo.TempDirPath, 'MW'));
                end
            end
            % TODO The RemoteUtilities does not support MATLAB
            % compiler deployment yet, need to remove the %#exclude
            % below and isdeployed once g3238819 is resolved
            %#exclude matlabshared.remoteconnectivity.internal.RemoteUtilities.isUsingRemoteHW
            if isdeployed || ~matlabshared.remoteconnectivity.internal.RemoteUtilities.isUsingRemoteHW()
                % Logic for MATLAB desktop
                if ismember(buildInfo.Board,arduinoio.internal.ArduinoConstants.BoardsRequireCompileAndUploadCommandsSeperately)
                    % special case for ESP devices for Linux and Mac, build
                    % first and then prompt user to press boot button, then upload, after
                    % successful upload ask user to release boot button
                    [status, result] = buildServer(obj,buildInfo);

                    if ~status
                        if ismember(buildInfo.Board,arduinoio.internal.ArduinoConstants.ESP32Boards)
                            %press boot button
                            arduinoio.internal.Utility.pressBootButtonDialog;

                            % upload binary
                            uploadCmd = [buildInfo.Programmer, ' -v --fqbn ', buildInfo.Package, ':', buildInfo.Arch, ':', buildInfo.BoardName];
                            if ~isempty(buildInfo.CPU)
                                uploadCmd = [uploadCmd, ':cpu=', buildInfo.CPU];
                            end
                            uploadCmd = [uploadCmd, ' upload ', '"',fullfile(buildInfo.TempDirPath),'"'];
                            uploadCmd = [uploadCmd, ' --port ', buildInfo.Port];
                            uploadCmd = [uploadCmd, ' --input-dir ', '"',fullfile(buildInfo.TempDirPath, 'MW'),'"'];%Added quotes around sketchfile path to overcome error caused by tempdir not resolving space in filepath
                            uploadCmd = [uploadCmd, ' --config-file ', '"',buildInfo.ConfigurationFile,'"'];
           		     end

                        % Upload
                        [status,result] = system(uploadCmd);

                        if ~status && ismember(buildInfo.Board,arduinoio.internal.ArduinoConstants.ESP32Boards)
                            arduinoio.internal.Utility.releaseBootButtonDialog;
                        end
                    end
                else
                    uploadCmd = [buildInfo.Programmer, ' -v --fqbn ', buildInfo.Package, ':', buildInfo.Arch, ':', buildInfo.BoardName];

                    if ~isempty(buildInfo.CPU)
                        uploadCmd = [uploadCmd, ':cpu=', buildInfo.CPU];
                    end
                    uploadCmd = [uploadCmd, ' compile --upload ', '"',fullfile(buildInfo.TempDirPath),'"'];
                    uploadCmd = [uploadCmd, ' --port ', buildInfo.Port];
                    uploadCmd = [uploadCmd, ' --build-path ', '"',fullfile(buildInfo.TempDirPath, 'MW'),'"'];%Added quotes around sketchfile path to overcome error caused by tempdir not resolving space in filepath
                    uploadCmd = [uploadCmd, ' --config-file ', '"',buildInfo.ConfigurationFile,'"'];
                    % Add the NOT_AN_INTERRUPT flag if needed
                    if strcmpi(buildInfo.Arch, 'renesas_uno')
                        uploadCmd = [uploadCmd, ' --build-property build.extra_flags=-DNOT_AN_INTERRUPT=-1 '];
                    end

                    [status, result] = system(uploadCmd);
                end
            else
                % Logic for MATLAB Online

                if ismember(buildInfo.Board, arduinoio.internal.ArduinoConstants.BoardsNotSupportedInOnline)
                    % ESP32 and Uno R4 support is pending the TODO items below
                    % Error out for now
                    matlabshared.hwsdk.internal.localizedError('MATLAB:arduinoio:general:BoardsNotSupportedMATLABOnline',char(buildInfo.Board));
                end

                % Build first, then upload the IO server with remote
                % utilities
                [status, result] = buildServer(obj,buildInfo);
                if ~status
                    % Only proceed if compilation succeed
                    boardFQBN = [buildInfo.Package, ':', buildInfo.Arch, ':', buildInfo.BoardName];
                    if ~isempty(buildInfo.CPU)
                        boardFQBN = [boardFQBN, ':cpu=', buildInfo.CPU];
                    end

                    if ismember(buildInfo.Board,{'ESP32-WROOM-DevKitV1','ESP32-WROOM-DevKitC'})
                        % ESP32 support errors out above. It is pending the
                        % TODO items below
                        % special case for ESP devices for Linux and Mac,
                        % prompt user to press boot button, then upload, after
                        % successful upload ask user to release boot button
                        % press boot button
                        arduinoio.internal.Utility.pressBootButtonDialog;

                        % TODO: upload binary
                        % TODO: send the ESP32 artifacts over using sendFile
                        % Blocker: it needs sendFile option to support
                        % sending a directory or specifying a sub folder in
                        % the receive folder
                        % TODO: Call arduino-cli to program the board, get
                        % status, append result.
                        % TODO: We need a new ESP32_FLASH command instead
                        % of ARDUINO_FLASH (g3178661)
                        % TODO: We also need to bundle the boot*.bin in
                        % arduinodownloadutils
                        % The ARDUINO_FLASH is using -i (--input-file)
                        % option (to include a single binary file), but
                        % ESP32 is using --input-dir (which requires
                        % multiple files), it includes a .bin file, a
                        % bootloader.bin file, a partitions.bin, which all
                        % need to be sent to the user's machine to be flashed.
                        % It also needs the boot_app0.bin (from esptool).
                        % Below is an example of the command and files
                        % needed for the upload command:
                        % esptool.exe --chip esp32 --port "COM6" --baud
                        % 921600 --before default_reset --after hard_reset
                        % write_flash  -z --flash_mode dio --flash_freq 80m
                        % --flash_size 4MB
                        % 0x1000 "S:\ArduinoServerESP32-WROOM-DevKitV1\MW/ArduinoServer.ino.bootloader.bin"
                        % 0x8000 "S:\ArduinoServerESP32-WROOM-DevKitV1\MW/ArduinoServer.ino.partitions.bin"
                        % 0xe000 "C:\aCLI\data\packages\esp32\hardware\esp32\2.0.11/tools/partitions/boot_app0.bin"
                        % 0x10000 "S:\ArduinoServerESP32-WROOM-DevKitV1\MW/ArduinoServer.ino.bin"

                        % Prompt to release the button if program is
                        % successful
                        if ~status
                            arduinoio.internal.Utility.releaseBootButtonDialog;
                        end
                    else
                        % Program Arduino boards
                        remoteUtils = matlabshared.remoteconnectivity.internal.RemoteUtilities();
                        % Send the binary file to user's machine
                        if ismember(buildInfo.Arch, {'sam','samd','mbed_nano','renesas_uno'})
                            % .bin file is used by the upload tools for these types of boards
                            binaryFileName = ['ArduinoServer' buildInfo.Board '.ino.bin'];
                        else
                            % .hex file is used by the upload tools for
                            % other types of boards, like AVR boards
                            binaryFileName = ['ArduinoServer' buildInfo.Board '.ino.hex'];
                        end
                        remoteUtils.sendFile(fullfile(buildInfo.TempDirPath, 'MW', binaryFileName));
                        % Program the binary to the board.
                        % Here remoteUtils.getRealPort() is used to get the port
                        % name of the hardware on the user's machine (Eg: COM3), for a
                        % given virtual port (/dev/pts/1) in MATLAB Online. This is
                        % mainly required for the Simulink IO case for
                        % Arduino Simulink.
                        [status, stdout, stderr] = remoteUtils.executeProcess('ARDUINO_FLASH', binaryFileName, boardFQBN, remoteUtils.getRealPort(buildInfo.Port));
                        % Append the output to the previous result
                        if ~isempty(stdout)
                            result = [result, newline, stdout];
                        end
                        if ~isempty(stderr)
                            result = [result, newline, stderr];
                        end
                    end
                end
            end
        end

               
        function [ArefMacroValue,ArefVoltage] = getAnalogReferenceMacro(~,buildInfo)
            %Return arduino specified macro values to set analog reference, as
            %per the analog reference voltage and mode specified by the
            %user. The macro values are defined in Arduino's library file
            %wiring_analog.h

            if strcmpi(buildInfo.AnalogReferenceMode,'external')
                %analog reference macro values for external mode
                if ismember(buildInfo.Board,{'MKR1000','MKR1010','MKRZero','Nano33IoT'})
                    ArefMacroValue = '2';
                else
                    ArefMacroValue = '0';
                end
            elseif strcmpi(buildInfo.AnalogReferenceMode,'internal')
                %analog reference macro values for internal mode

                if (buildInfo.AnalogReference == 3.3 || buildInfo.AnalogReference == 5.0)
                    switch buildInfo.Board
                        case {'Uno','UnoR4WiFi','UnoR4Minima','Nano3','ProMini328_3V','ProMini328_5V','DigitalSandbox','Mega2560','MegaADK','Leonardo','Micro'}
                            ArefMacroValue = '1';
                        case {'MKR1000','MKR1010','MKRZero','Due','Nano33IoT','Nano33BLE','NanoRP2040Connect','ESP32-WROOM-DevKitV1','ESP32-WROOM-DevKitC','RaspberryPiPico','RaspberryPiPicoW','Teensy41','Teensy40'}
                            % Due, MKRs, Nano33IoT Nano33BLE and ESP32 support internal default reference voltage
                            % of 3.3 volt
                            ArefMacroValue = '0';
                    end
                else
                    switch buildInfo.Board
                        case {'Uno','Nano3','ProMini328_3V','ProMini328_5V','DigitalSandbox','Leonardo','Micro'}
                            ArefMacroValue = '3';
                        case {'Mega2560','MegaADK'}
                            if buildInfo.AnalogReference == arduinoio.internal.ArduinoConstants.InternalAnalogReferenceAVR{1}
                                ArefMacroValue = '2';
                            elseif buildInfo.AnalogReference == arduinoio.internal.ArduinoConstants.InternalAnalogReferenceAVR{2}
                                ArefMacroValue = '3';
                            end
                        case {'MKR1000','MKR1010','MKRZero','Nano33IoT'}
                            if buildInfo.AnalogReference == arduinoio.internal.ArduinoConstants.InternalAnalogReferenceSAMD{1}
                                ArefMacroValue = '3';
                            elseif buildInfo.AnalogReference == arduinoio.internal.ArduinoConstants.InternalAnalogReferenceSAMD{2}
                                ArefMacroValue = '4';
                            elseif buildInfo.AnalogReference == arduinoio.internal.ArduinoConstants.InternalAnalogReferenceSAMD{3}
                                ArefMacroValue = '5';
                            end
                    end
                end
            elseif (isempty(buildInfo.AnalogReferenceMode) && isempty(buildInfo.AnalogReference))
                % If a server doesn't already exist on the arduino board,
                % and user hasn't provided the analog reference values
                % initialize server with default analog reference values.
                switch buildInfo.Board
                    case {'DigitalSandbox', 'ProMini328_3V'}
                        buildInfo.AnalogReference = 3.3;
                        ArefMacroValue = '1';
                    case {'Due','MKR1000','MKR1010','MKRZero','Nano33IoT','Nano33BLE','ESP32-WROOM-DevKitV1','ESP32-WROOM-DevKitC'}
                        % Due,MKRs, Nano33IoT, Nano33BLE, and ESP32 support internal default reference voltage
                        % of 3.3 volts
                        buildInfo.AnalogReference = 3.3;
                        ArefMacroValue = '0';
                    case {'Uno','UnoR4WiFi','UnoR4Minima','Nano3','ProMini328_5V','Mega2560','MegaADK','Leonardo','Micro'}
                        buildInfo.AnalogReference = 5.0;
                        ArefMacroValue = '1';
                end
            end
            ArefVoltage = buildInfo.AnalogReference;
        end
    end

    methods(Access = {?arduino.accessor.UnitTest})
        function buildInfo = preBuildProcess(obj,buildInfo)
            % Populate all needed fields in buildInfo other than those got from
            % boards.xml
            switch buildInfo.MCU
                case 'cortex-m3'
                    buildInfo.Arch = 'sam';
                case 'cortex-m0plus'
                    if matches(buildInfo.Board,'NanoRP2040Connect')
                        buildInfo.Arch = 'mbed_nano';
                    elseif (matches(buildInfo.Board,'RaspberryPiPico') || matches(buildInfo.Board,'RaspberryPiPicoW'))
                        buildInfo.Arch = 'rp2040';
                    else
                        buildInfo.Arch = 'samd';
                    end
                case 'cortex-m4'
                    if ismember(buildInfo.Board,{'UnoR4Minima','UnoR4WiFi'})
                        buildInfo.Arch = 'renesas_uno';
                    else
                        buildInfo.Arch = 'mbed_nano';
                    end
                case 'esp32'
                    buildInfo.Arch = 'esp32';
                otherwise
                    buildInfo.Arch = 'avr';
            end
            try
                if ismember(buildInfo.Board,{'ESP32-WROOM-DevKitV1','ESP32-WROOM-DevKitC'})
                    if ~exist(fullfile(arduinoio.CLIRoot,"data","packages","esp32"),'dir')
                        matlabshared.hwsdk.internal.localizedError('MATLAB:arduinoio:general:thirdpartyLibNotInstalled','ESP32');
                    elseif ismember('Servo',buildInfo.Libraries) && ~exist(fullfile(arduinoio.CLIRoot,"user","libraries","ServoESP32"),'dir')
                        matlabshared.hwsdk.internal.localizedError('MATLAB:arduinoio:general:thirdpartyLibNotInstalled','ESP32 Servo');
                    end
                end
            catch e
                throwAsCaller(e);
            end
            buildInfo = getProgrammer(obj, buildInfo); % set the Programmer field of buildInfo structure
            %Moved to arduino class to remove the sharedcomponent
            %dependency on Arduino IO support package
            % buildInfo.SPPKGPath = arduinoio.SPPKGRoot;
            buildInfo.SketchTemplate = fullfile(arduinoio.SharedArduinoRoot, 'target', 'ArduinoServer.ino');
            buildInfo.SketchFile = fullfile(buildInfo.TempDirPath, strcat('ArduinoServer', buildInfo.Board, '.ino'));
            [mheaders, libs] = areLibrariesAvailable(obj, buildInfo);
            if ~isempty(mheaders)
                matlabshared.hwsdk.internal.localizedError('MATLAB:arduinoio:general:addonLibraryNotInstalled', mheaders, strjoin(libs, ', '));
            end
        end

        function currentSize = validateServerSize(~, buildInfo)
            % Check whether the compiled server fits in the flash memory
            % available
            if strcmp(buildInfo.Arch, 'avr')
                executableFile = fullfile(buildInfo.TempDirPath, 'MW', ['ArduinoServer' buildInfo.Board '.ino.hex']);
                % Updating the sizer path
                sizer = fullfile(buildInfo.CLIPath, 'data','packages','arduino','tools','avr-gcc','7.3.0-atmel3.6.1-arduino7','bin', 'avr-size');
                [~, result] = system([sizer, ' ', '"', executableFile, '"']);
                fields = textscan(result, '%s', 'delimiter', newline); fields = fields{1}{end};
                fields = textscan(fields, '%s');
                currentSize = char(fields{1}(2));
            elseif strcmpi(buildInfo.Arch, 'renesas_uno')
                executableFile = fullfile(buildInfo.TempDirPath, 'MW', ['ArduinoServer' buildInfo.Board '.ino.elf']);
                % Updating the sizer path
                sizer = fullfile(buildInfo.CLIPath, 'data','packages','arduino','tools','arm-none-eabi-gcc','7-2017q4','bin', 'arm-none-eabi-size');
                [~, result] = system([sizer, ' ', '"', executableFile, '"']);
                fields = textscan(result, '%s', 'delimiter', newline); fields = fields{1}{end};
                fields = textscan(fields, '%s');
                currentSize = char(fields{1}(1));
            elseif ismember(buildInfo.Arch,{'sam','samd','mbed_nano','esp32','rp2040'})
                % SAM/SAMD/MBED/Xtensa boards - Due, MKRXXXX (MKR1010, MKRZero, MKR1000), Nano33IoT, Nano33BLE, ESP32 etc.

                % Get the size of the binary file
                executableFile = fullfile(buildInfo.TempDirPath, 'MW', ['ArduinoServer' buildInfo.Board '.ino.bin']);
                fileInfo = dir(executableFile);
                currentSize = num2str(fileInfo.bytes);
            end
            % Check if the currentSize is valid. If currentSize is not
            % a number then str2double returns NaN value.
            assert(~isnan(str2double(currentSize)), getString(message('MATLAB:arduinoio:general:serverValidationFailed')));
            if str2double(currentSize) > buildInfo.MemorySize
                matlabshared.hwsdk.internal.localizedError('MATLAB:arduinoio:general:outOfFlashMemory', buildInfo.Board, matlabshared.hwsdk.internal.renderCellArrayOfCharVectorsToCharVector(buildInfo.Libraries, ', '));
            end
        end


    end

    methods(Access = {?ioservertest.hostIOServer.hostIOServerUtility})
        % Granting access to the hostIOServerUtility class for enabling
        % hostIOServer mock for establishing communication with an arduino
        % object on a pseudo terminal
        function generateAddonLibrariesHeader(obj, buildInfo)
            % Generate Dynamic.h file to be compiled with other source code to add the Addon libraries
            filename = fullfile(buildInfo.TempDirPath, 'addOnLibraries.h');
            h = fopen(filename, 'w');
            c = onCleanup(@() fclose(h));
            contents = [];
            contents = '#include "Arduino.h"\n';
            contents = [contents '#include "LibraryBase.h"\n'];
            contents = [contents,'#include "MWArduinoClass.h"\n'];
            if strcmpi(buildInfo.Board,'Uno')
                % Use this macro to determine how much memory to allocate
                % for Adafruit motor shields with stacking.
                contents = [contents,'#define MW_UNO_SHIELDS 1','\n'];
            end
            for libCount = 1:length(buildInfo.Libraries)
                % Check if specified library is using the IOServer's addon infrastructure, include the
                % headerFile for the same
                if ~ismember(buildInfo.Libraries(libCount),arduinoio.internal.ArduinoConstants.ShippingLibraries) && ~ismember(buildInfo.Libraries(libCount),arduinoio.internal.ArduinoConstants.AutogeneratedLibraries)
                    headerFile = arduinoio.internal.getDefaultLibraryPropertyValue(buildInfo.Libraries{libCount}, 'CppHeaderFile');
                    headerFile = strrep(headerFile, '\', '\\');
                    contents = strcat(contents, ['#include "', headerFile, '"\n']);
                end
            end

            contents = [contents,'MWArduinoClass hwObject;\n'];

            for libCount = 1:length(buildInfo.Libraries)
                if ~ismember(buildInfo.Libraries(libCount),arduinoio.internal.ArduinoConstants.ShippingLibraries) && ~ismember(buildInfo.Libraries(libCount),arduinoio.internal.ArduinoConstants.AutogeneratedLibraries)
                    className = arduinoio.internal.getDefaultLibraryPropertyValue(buildInfo.Libraries{libCount}, 'CppClassName');
                    contents = strcat(contents, [className, ' a', className, '(hwObject); // ID = ', num2str(libCount-1), '\n']);
                end
            end
            try
                fwrite(h, sprintf(contents));
            catch
                f2 = strrep(filename, '\', '\\');
                matlabshared.hwsdk.internal.localizedError('MATLAB:hwshared:general:noWritePermission');
            end
        end

        function generatePeripheralIncludeHeader(obj, buildInfo)
            % Generate Dynamic.h file to be compiled with other source code to
            % register the libraries
            if ~exist(fullfile(buildInfo.TempDirPath), 'dir')
                try
                    mkdir(fullfile(buildInfo.TempDirPath));
                catch
                    matlabshared.hwsdk.internal.localizedError('MATLAB:hwshared:general:noWritePermission');
                end
            end

            filename = fullfile(buildInfo.TempDirPath, 'peripheralIncludes.h');
            h = fopen(filename, 'w');
            c = onCleanup(@() fclose(h));

            for numBoard = 1:length(obj.BoardInfo.Boards)
                if strcmpi(obj.BoardInfo.Boards(numBoard).BoardName,buildInfo.BoardName)
                    break;
                end
            end
            if ismember(buildInfo.Board,{'Due','Nano33BLE'})
                AvailableI2CBusIDs = 2;
            else
                AvailableI2CBusIDs = 1;
            end

            % MATLAB Workflow
            if ~isfield(buildInfo,'PinsSerial')
                if (ismember(buildInfo.Board,{'Mega2560','MegaADK','Due'}))
                    % IO_SCI_MODULES_MAX is used to identify the
                    % boards as well as maximum number of modules which we can
                    % use.
                    numModulesSCI = num2str(3);
                elseif (ismember(buildInfo.Board,{'MKR1000','MKR1010','MKRZero','Leonardo','Micro','Nano33IoT','Nano33BLE'}))
                    numModulesSCI = num2str(1);
                elseif ismember(buildInfo.Board,{'ESP32-WROOM-DevKitV1','ESP32-WROOM-DevKitC'})
                    numModulesSCI = num2str(2);
                else
                    numModulesSCI = num2str(0);
                end
            else
                %Simulink Connected IO Workflow
                numModulesSCI=numel(buildInfo.PinsSerial)/2;
            end

            if strcmpi(buildInfo.Board,'MKRZero')
                %highest digital pin index on MKRZero is D32 which is a
                %digital pin therefore, using that for initializing
                %peripheral handle map
                numPinsDigital = num2str(obj.BoardInfo.Boards(numBoard).PinsDigital(length(obj.BoardInfo.Boards(numBoard).PinsDigital))+1);
            end
            % since, peripheraltohandle map maintains a map with assumption
            % that pins are indexed according to the number so first
            % digital pin is assumed to be indexed 0 and so on. Therefore,
            % making IO_DIGITAlIO_MODULES_MAX = index of highest digital pin
            numPinsAnalog = num2str(obj.BoardInfo.Boards(numBoard).PinsAnalog(length(obj.BoardInfo.Boards(numBoard).PinsAnalog))+1);
            numPinsPWM = num2str(obj.BoardInfo.Boards(numBoard).PinsPWM(length(obj.BoardInfo.Boards(numBoard).PinsPWM))+1);
            contents = ['#ifndef PERIPHERALINCLUDES_H_\n',...
                '#define PERIPHERALINCLUDES_H_\n\n',...
                '#define INCLUDE_FUNCTION_MACROS\n',...
                '#define MAX_PACKET_SIZE ',num2str(buildInfo.MAXPacketSize+16),'\n',... % 15 bytes is the IOServer payload overhead
                '#define IO_CUSTOM_ENABLE 1\n',...
                '#define IO_STANDARD_ENABLE 1\n',...
                '#if IO_STANDARD_ENABLE\n \n',...
                '#define IO_STANDARD_DIGITALIO 1\n',...
                '#define IO_SPI_MODULES_MAX ','1','\n'... % Arduino hasn't come up with multiple SPI buses yet.
                '#define IO_CS_BY_SPI_DRIVER ','1','\n'... % Manage CS Pin in SVD for Arduino
                '#define IO_I2C_MODULES_MAX ',num2str(AvailableI2CBusIDs),'\n'...
                '#define IO_STANDARD_ANALOGINPUT 1\n',...
                '#define IO_ANALOGINPUT_MODULES_MAX ',numPinsAnalog,'\n',...
                '#define IO_STANDARD_PWM 1\n',...
                '#define IO_PWM_MODULES_MAX ',numPinsPWM,'\n'...
                '#define SOFT_REALTIME_SCHEDULING \n']; % Arduino has soft real time implementation for streaming.
            if strcmpi(buildInfo.Board,'MKRZero')
                contents = [contents,'#define IO_DIGITALIO_MODULES_MAX ',numPinsDigital,'\n'];
            else
                if strcmpi(buildInfo.Board,'Due')
                    % numPinsAnalog here indicates the maximum number of
                    % digitals pins that can be used on a particular board.
                    % Adding required logic for Due to support new pins.
                    % For most of the boards the last analog pin number
                    % indicates the total number of digital pins, but
                    % this is not true for Due board.
                    index = find(strcmp({obj.BoardInfo.Boards.Name}, 'Due')==1);
                    numPinsAnalog = num2str(obj.BoardInfo.Boards(index).NumPins);
                end
                contents = [contents,'#define IO_DIGITALIO_MODULES_MAX ',numPinsAnalog,'\n']; % All Analog Pins can also be used as digital pin and need to assign peripheral handle map of size of index of highest DigitalPin,
            end

            % check for Add-on Libraries to enable ADD_ON flag
            if any(~ismember(buildInfo.Libraries,arduinoio.internal.ArduinoConstants.ShippingLibraries))
                contents = strcat(contents,'#define ADD_ON 1\n');
            end
            libs = char(strjoin(buildInfo.Libraries,','));
            for libCount = 1:length(buildInfo.Libraries)
                if any(ismember(arduinoio.internal.ArduinoConstants.ShippingLibraries,buildInfo.Libraries(libCount)))
                    switch char(buildInfo.Libraries(libCount))
                        case 'I2C'
                            contents = strcat(contents,'#define IO_STANDARD_I2C 1\n');
                        case 'SPI'
                            contents = strcat(contents,'#define IO_STANDARD_SPI 1\n');
                        case 'Servo'
                            contents = strcat(contents,'#define IO_CUSTOM_SERVO 1\n');
                        case 'RotaryEncoder'
                            if ismember(buildInfo.Board,arduinoio.internal.ArduinoConstants.RotaryEncoderSupportedBoards)
                                contents = strcat(contents,'#define IO_CUSTOM_ROTARYENCODER 1\n');
                            end
                        case 'Ultrasonic'
                            contents = strcat(contents,'#define IO_CUSTOM_ULTRASONIC 1\n');
                        case 'NeoPixel'
                            if (~isequal(buildInfo.Arch,'mbed'))
                                contents = strcat(contents,'#define IO_CUSTOM_NEOPIXEL 1\n');
                            end
                        case 'ShiftRegister'
                            contents = strcat(contents,'#define IO_CUSTOM_SHIFTREGISTER 1\n');
                        case 'Serial'
                            % IO_STANDARD_SCI should only be included where
                            % extra onboard UART is available.This will also
                            % ensure Serial related files are not flashed on
                            % low memory boards like UNO.
                            %MATLAB Workflow
                            if ~isfield(buildInfo,'PinsSerial')
                                if ismember(buildInfo.Board,arduinoio.internal.ArduinoConstants.SerialLibrarySupportBoards)
                                    contents = strcat(contents,'#define IO_STANDARD_SCI 1\n');
                                    contents = [contents,'#define IO_SCI_MODULES_MAX ',numModulesSCI,'\n'];%#ok<AGROW>
                                end
                            else
                                % %Simulink Connected IO Workflow
                                if ~isempty(buildInfo.PinsSerial)
                                    contents = strcat(contents,'#define IO_STANDARD_SCI 1\n');
                                    contents = [contents,'#define IO_SCI_MODULES_MAX ',num2str(numModulesSCI),'\n'];%#ok<AGROW>
                                end
                            end
                    end
                end
            end

            obj.AutoGeneratedWrapperFilesRequired=0;
            if ~isempty(intersect(buildInfo.Libraries,arduinoio.internal.ArduinoConstants.AutogeneratedLibraries))
                contents = strcat(contents,'#define IO_AUTOGEN_ENABLE 1\n');
                obj.AutoGeneratedWrapperFilesRequired=1;

                if obj.AutoGeneratedWrapperFilesRequired
                    macros = zeros(size(arduinoio.internal.ArduinoConstants.AutogeneratedLibraries));
                    % Find the common elements
                    commonElements = ismember(arduinoio.internal.ArduinoConstants.AutogeneratedLibraries, buildInfo.Libraries);
                    % Set the value of the common elements to 1
                    macros(commonElements) = 1;
                    % Generate the macros
                    for i = 1:numel(arduinoio.internal.ArduinoConstants.AutogeneratedLibraries)
                        macro = strcat("#define IO_AUTOGEN_", upper(arduinoio.internal.ArduinoConstants.AutogeneratedLibraries(i)), " ", num2str(macros(i)),'\n');
                        contents = strcat(contents, macro);
                    end

                    if ismember('InputCapture',buildInfo.Libraries)
                        contents = strcat(contents,'#define _ROTH_',upper(buildInfo.Board),'_ 1\n');
                    end

                    if ismember('AnalogOutput',buildInfo.Libraries)
                        if (ismember(buildInfo.Board,{'Due'}))
                            contents = strcat(contents, "#define _ROTH_DUE_ 1\n");
                        elseif (ismember(buildInfo.Board,{'MKR1010','MKRZero'}))
                            contents = strcat(contents, "#define _ROTH_MKRZERO_ 1\n");
                        elseif (ismember(buildInfo.Board,{'MKR1000','Nano33IoT'}))
                            contents = strcat(contents, "#define _ROTH_MKR1000_ 1\n");
                        elseif ismember(buildInfo.Board,{'ESP32-WROOM-DevKitV1','ESP32-WROOM-DevKitC'})
                            contents = strcat(contents, "#define _ROTH_ESP32_ 1\n");
                        end
                    end
                end

                if ismember('WiFiTCP',buildInfo.Libraries)
                    contents = strcat(contents, "#define _RTT_WIFI_TCP_SERVER_ 1\n");
                    contents = strcat(contents, "#define _RTT_WIFI_TCP_CLIENT_ 1\n");
                    contents = strcat(contents, "#define _RTT_WIFI_TCP_ 1\n");
                end

                if ismember('WiFiUDP',buildInfo.Libraries)
                    contents = strcat(contents, "#define _RTT_WIFI_UDP_ 1\n");
                end

                if ismember('WiFiMQTT',buildInfo.Libraries)
                    % Need to hard code here since there is no way update
                    % defines on the fly and avoid rebuilding
                    contents = strcat(contents, "#define MQTT_WIFI_SUBSCRIBE_BLOCKS_PRESENT\n");
                    contents = strcat(contents, "#define MW_MQTT_NUM_SUBSCRIBE_BLOCKS 5\n");
                end

                if ismember('WiFiHTTP',buildInfo.Libraries)
                    if ismember(buildInfo.Board,{'ESP32-WROOM-DevKitV1','ESP32-WROOM-DevKitC'})
                        % Only esp32 boards have configset input of the
                        % certificate file path
                        % Placeholder to add certificate header file when
                        % ESP32 is supported
                    end
                end

                if ismember('WiFiThingspeak',buildInfo.Libraries)
                    contents = strcat(contents, "#define _RTT_THINGSPEAK_WIFI_ 1\n");
                    contents = strcat(contents, ['#define THINGSPEAK_URL "' codertarget.arduinobase.internal.getThingspeakURL '"\n']);
                end

                if ismember('WiFiTCP',buildInfo.Libraries) || ismember('WiFiUDP',buildInfo.Libraries) ...
                        || ismember('WiFiMQTT',buildInfo.Libraries) || ismember('WiFiHTTP',buildInfo.Libraries) || ismember('WiFiThingspeak',buildInfo.Libraries)
                    switch buildInfo.Board
                        case {'MKR1010','Nano33IoT'}
                            contents = strcat(contents, "#define ARDUINO_WIFI_LIB_NINA 1\n");
                        case {'MKR1000'}
                            contents = strcat(contents, "#define ARDUINO_WIFI_LIB_101 1\n");
                    end
                    contents = strcat(contents, "#define IO_AUTOGEN_WIFI 1\n");
                    contents = strcat(contents, "#define IO_PAYLOADFIELDSIZE 2\n");
                else
                    contents = strcat(contents, "#define IO_AUTOGEN_WIFI 0\n");
                end
            end
            contents = strcat(contents,'#endif\n');%endif for #if IO_STANDARD_ENABLE',...


            % LTC_BAREMETAL_HARDWARE macro removes function calls from IO_wrapper which are not used by Arduino IO
            if ~(isfield(buildInfo,'AdvancedServer'))
                contents =  strcat(contents,'#define LTC_BAREMETAL_HARDWARE\n');
            end

            if(buildInfo.ConnectionType == matlabshared.hwsdk.internal.ConnectionTypeEnum.BLE)
                contents = [contents, '#define MW_IOSERVER_FIXED_FRAME_COMMUNICATION','\n'];
                contents = [contents, '#define MAX_PACKET_SIZE ',num2str(512),'\n'];
            end

            trace = num2str(0);
            if buildInfo.TraceOn
                if (isfield(buildInfo,'AdvancedServer'))
                    contents = [contents,'\n#define DEBUG_FLAG 1\n'];
                elseif ispref('MATLAB_HARDWARE','HostIOServerEnabled') && getpref('MATLAB_HARDWARE','HostIOServerEnabled')
                    % Do not add any macro for HostIOServer
                else
                    contents = [contents,'\n#define DEBUG_FLAG 2\n'];
                end
                trace = num2str(1);
            end
            % add ServerInfo to the IOServer
            contents = [char(contents), '\n#define BOARDNAME ','"',buildInfo.Board,'"','\n',...
                '#define CUSTOMDATA "BAUDRATE ',' ',buildInfo.BaudRate,',','Trace ',' ',trace];

            if isfield(buildInfo,'SerialPort') %Simulink Connected IO
                contents = [char(contents), ',','SerialPortUsed ',' ',buildInfo.SerialPort];
            end

            if isfield(buildInfo,'AnalogReference')
                [ArefMacroValue,ArefVoltage]=getAnalogReferenceMacro(obj,buildInfo);

                %append analog reference macro value and analog reference voltage with CUSTOMDATA
                contents = [char(contents), ',','AREFMACRO ',' ',ArefMacroValue,',','AREFVOLT ',' ',num2str(ArefVoltage),'"','\n'];

                %Value assigned to MW_AREF is passed to analogReference()
                %function at server side
                contents=  [char(contents),'#define MW_AREF ',ArefMacroValue,'\n'];
            else
                contents = [char(contents),'"','\n'];
            end
            contents = [char(contents),'#define BOARD_IO_VERSION ',' ','"',buildInfo.HWSPPKGVersion,'"','\n',...
                '#define LIBNAMES ',' ','"',libs,'"','\n'];
            % Sample ServerInfo in PeripheralIncludes.h
            % #define BOARDNAME "Uno"
            % #define CUSTOMDATA "BAUDRATE  115200,Trace  0"
            % #define BOARD_IO_VERSION  "19.1.0"
            % #define LIBNAMES  "I2C,SPI,Servo"

            contents = [contents,'\n#define USE_BIT_FOR_HANDLE 1\n'];   % Saving memory on Arduino (use Bit instead of Byte for Handle)
            contents = [contents, '\n#define CHECKSUM_ENABLE 1\n\n#endif\n']; %endif for '#ifndef PERIPHERALINCLUDES_H_\n',...
            try
                fwrite(h, sprintf(contents));
            catch
                f2 = strrep(filename, '\', '\\');
                matlabshared.hwsdk.internal.localizedError('MATLAB:hwshared:general:noWritePermission');
            end
        end
    end
end

% LocalWords:  ARDUINOIO avr arduinoio Arduino's FTDI vid tty symlink readlink
% LocalWords:  dev serialportlist btspp ICT Bluetooth bluetooth BT nslookup ip pid
% LocalWords:  CPATH DYLD MKR stk getsync SPI sam samd ino addon hwshared WIFI
% LocalWords:  TRACEON BAUDRATE wifi WPA WEP KEYINDEX Uno Adafruit UNO LD
